<?php

namespace Pterodactyl\Services\Proxy;

use Pterodactyl\Models\ServerSubdomain;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\File;

class NginxStreamService
{
    /**
     * Generate NGINX stream block configuration for a subdomain.
     */
    public function generateStreamConfig(ServerSubdomain $subdomain): string
    {
        $server = $subdomain->server;
        $allocation = $server->allocation;

        if (!$allocation) {
            throw new \Exception('Server does not have an allocation.');
        }

        // Use IP alias if available, otherwise use IP
        $containerIp = $allocation->ip_alias ?? $allocation->ip;
        $containerPort = $allocation->port;
        $proxyPort = $subdomain->proxy_port ?? config('proxy.default_proxy_port', 25565);
        $protocol = config('proxy.proxy_protocol', 'tcp');
        $timeout = config('proxy.proxy_timeout', 1);
        $responses = config('proxy.proxy_responses', 1);

        $config = <<<NGINX
# Auto-generated by Pyrodactyl - Do not edit manually
# Subdomain ID: {$subdomain->id}
# Server ID: {$server->id}
# Generated: {$subdomain->updated_at->toIso8601String()}

upstream subdomain_{$subdomain->id} {
    server {$containerIp}:{$containerPort};
}

server {
    listen {$proxyPort};
    proxy_pass subdomain_{$subdomain->id};
    proxy_timeout {$timeout}s;
    proxy_responses {$responses};
    error_log /var/log/nginx/subdomain_{$subdomain->id}_error.log;
}
NGINX;

        return $config;
    }

    /**
     * Write NGINX stream configuration to file.
     */
    public function writeConfig(ServerSubdomain $subdomain): bool
    {
        if (!config('proxy.enabled', false)) {
            Log::info('Proxy functionality is disabled, skipping config write', [
                'subdomain_id' => $subdomain->id,
            ]);
            return false;
        }

        $configPath = config('proxy.nginx_config_path', '/etc/nginx/stream.d');
        $configFile = $configPath . '/subdomain-' . $subdomain->id . '.conf';

        // Check for existing config files that might conflict (same port)
        // This is a safety check in case validation was bypassed or there are orphaned configs
        if (File::isDirectory($configPath)) {
            $proxyPort = $subdomain->proxy_port;
            if ($proxyPort) {
                $existingConfigs = File::glob($configPath . '/subdomain-*.conf');
                foreach ($existingConfigs as $existingConfig) {
                    // Extract subdomain ID from filename
                    if (preg_match('/subdomain-(\d+)\.conf$/', $existingConfig, $matches)) {
                        $existingSubdomainId = (int) $matches[1];
                        if ($existingSubdomainId === $subdomain->id) {
                            continue; // Skip our own config
                        }

                        // Read existing config to check if it uses the same port
                        try {
                            $existingContent = File::get($existingConfig);
                            if (preg_match('/listen\s+(\d+);/', $existingContent, $portMatch)) {
                                $existingPort = (int) $portMatch[1];
                                if ($existingPort === $proxyPort) {
                                    // Try to get the subdomain info for better error message
                                    $conflictingSubdomain = \Pterodactyl\Models\ServerSubdomain::find($existingSubdomainId);
                                    $conflictInfo = $conflictingSubdomain 
                                        ? "subdomain {$conflictingSubdomain->full_domain} (ID: {$existingSubdomainId})"
                                        : "config file {$existingConfig}";
                                    
                                    Log::warning('Port conflict detected in NGINX config', [
                                        'subdomain_id' => $subdomain->id,
                                        'proxy_port' => $proxyPort,
                                        'conflicting_config' => $existingConfig,
                                        'conflicting_subdomain_id' => $existingSubdomainId,
                                    ]);
                                    throw new \Exception("Port {$proxyPort} is already in use by {$conflictInfo}. Each subdomain must use a unique proxy port because NGINX cannot route TCP connections by domain name.");
                                }
                            }
                        } catch (\Exception $e) {
                            // If we can't read the file, log but don't fail - validation should have caught this
                            Log::warning('Could not read existing NGINX config for conflict check', [
                                'config_file' => $existingConfig,
                                'error' => $e->getMessage(),
                            ]);
                        }
                    }
                }
            }
        }

        // Ensure directory exists
        if (!File::isDirectory($configPath)) {
            try {
                File::makeDirectory($configPath, 0755, true);
            } catch (\Exception $e) {
                Log::error('Failed to create NGINX config directory', [
                    'path' => $configPath,
                    'error' => $e->getMessage(),
                ]);
                throw new \Exception("Failed to create NGINX config directory: {$e->getMessage()}");
            }
        }

        try {
            $config = $this->generateStreamConfig($subdomain);
            File::put($configFile, $config);
            File::chmod($configFile, 0644);

            Log::info('NGINX stream config written', [
                'subdomain_id' => $subdomain->id,
                'config_file' => $configFile,
            ]);

            return true;
        } catch (\Exception $e) {
            Log::error('Failed to write NGINX stream config', [
                'subdomain_id' => $subdomain->id,
                'config_file' => $configFile,
                'error' => $e->getMessage(),
            ]);
            throw new \Exception("Failed to write NGINX config: {$e->getMessage()}");
        }
    }

    /**
     * Delete NGINX stream configuration file.
     */
    public function deleteConfig(ServerSubdomain $subdomain): bool
    {
        if (!config('proxy.enabled', false)) {
            Log::info('Proxy functionality is disabled, skipping config deletion', [
                'subdomain_id' => $subdomain->id,
            ]);
            return false;
        }

        $configPath = config('proxy.nginx_config_path', '/etc/nginx/stream.d');
        $configFile = $configPath . '/subdomain-' . $subdomain->id . '.conf';

        try {
            if (File::exists($configFile)) {
                File::delete($configFile);
                Log::info('NGINX stream config deleted', [
                    'subdomain_id' => $subdomain->id,
                    'config_file' => $configFile,
                ]);
            }

            return true;
        } catch (\Exception $e) {
            Log::error('Failed to delete NGINX stream config', [
                'subdomain_id' => $subdomain->id,
                'config_file' => $configFile,
                'error' => $e->getMessage(),
            ]);
            throw new \Exception("Failed to delete NGINX config: {$e->getMessage()}");
        }
    }

    /**
     * Reload NGINX configuration.
     */
    public function reloadNginx(): bool
    {
        if (!config('proxy.enabled', false)) {
            Log::info('Proxy functionality is disabled, skipping NGINX reload');
            return false;
        }

        $command = config('proxy.nginx_reload_command', 'nginx -s reload');

        try {
            $output = [];
            $returnCode = 0;
            
            // Use exec to capture output
            exec($command . ' 2>&1', $output, $returnCode);
            $output = implode("\n", $output);

            if ($returnCode === 0) {
                Log::info('NGINX reloaded successfully', [
                    'command' => $command,
                ]);
                return true;
            } else {
                Log::error('NGINX reload failed', [
                    'command' => $command,
                    'return_code' => $returnCode,
                    'output' => $output,
                ]);
                throw new \Exception("NGINX reload failed: {$output}");
            }
        } catch (\Exception $e) {
            Log::error('Exception during NGINX reload', [
                'command' => $command,
                'error' => $e->getMessage(),
            ]);
            throw new \Exception("Failed to reload NGINX: {$e->getMessage()}");
        }
    }

    /**
     * Validate NGINX configuration syntax.
     */
    public function validateConfig(string $config): bool
    {
        // Write config to temporary file
        $tempFile = tempnam(sys_get_temp_dir(), 'nginx_validate_');
        File::put($tempFile, $config);

        try {
            $command = "nginx -t -c {$tempFile} 2>&1";
            $output = [];
            $returnCode = 0;
            exec($command, $output, $returnCode);

            // Clean up temp file
            File::delete($tempFile);

            return $returnCode === 0;
        } catch (\Exception $e) {
            // Clean up temp file on error
            if (File::exists($tempFile)) {
                File::delete($tempFile);
            }
            return false;
        }
    }
}
