<?php

namespace Pterodactyl\Services\Proxy;

use Pterodactyl\Models\ServerSubdomain;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\File;

class NginxStreamService
{
    /**
     * Generate NGINX stream block configuration for a subdomain.
     */
    public function generateStreamConfig(ServerSubdomain $subdomain): string
    {
        $server = $subdomain->server;
        $allocation = $server->allocation;

        if (!$allocation) {
            throw new \Exception('Server does not have an allocation.');
        }

        // Use IP alias if available, otherwise use IP
        $containerIp = $allocation->ip_alias ?? $allocation->ip;
        $containerPort = $allocation->port;
        $proxyPort = $subdomain->proxy_port ?? config('proxy.default_proxy_port', 25565);
        $protocol = config('proxy.proxy_protocol', 'tcp');
        $timeout = config('proxy.proxy_timeout', 1);
        $responses = config('proxy.proxy_responses', 1);

        $config = <<<NGINX
# Auto-generated by Pyrodactyl - Do not edit manually
# Subdomain ID: {$subdomain->id}
# Server ID: {$server->id}
# Generated: {$subdomain->updated_at->toIso8601String()}

upstream subdomain_{$subdomain->id} {
    server {$containerIp}:{$containerPort};
}

server {
    listen {$proxyPort};
    proxy_pass subdomain_{$subdomain->id};
    proxy_timeout {$timeout}s;
    proxy_responses {$responses};
    error_log /var/log/nginx/subdomain_{$subdomain->id}_error.log;
}
NGINX;

        return $config;
    }

    /**
     * Write NGINX stream configuration to file.
     */
    public function writeConfig(ServerSubdomain $subdomain): bool
    {
        if (!config('proxy.enabled', false)) {
            Log::info('Proxy functionality is disabled, skipping config write', [
                'subdomain_id' => $subdomain->id,
            ]);
            return false;
        }

        $configPath = config('proxy.nginx_config_path', '/etc/nginx/stream.d');
        $configFile = $configPath . '/subdomain-' . $subdomain->id . '.conf';

        // Ensure directory exists
        if (!File::isDirectory($configPath)) {
            try {
                File::makeDirectory($configPath, 0755, true);
            } catch (\Exception $e) {
                Log::error('Failed to create NGINX config directory', [
                    'path' => $configPath,
                    'error' => $e->getMessage(),
                ]);
                throw new \Exception("Failed to create NGINX config directory: {$e->getMessage()}");
            }
        }

        try {
            $config = $this->generateStreamConfig($subdomain);
            File::put($configFile, $config);
            File::chmod($configFile, 0644);

            Log::info('NGINX stream config written', [
                'subdomain_id' => $subdomain->id,
                'config_file' => $configFile,
            ]);

            return true;
        } catch (\Exception $e) {
            Log::error('Failed to write NGINX stream config', [
                'subdomain_id' => $subdomain->id,
                'config_file' => $configFile,
                'error' => $e->getMessage(),
            ]);
            throw new \Exception("Failed to write NGINX config: {$e->getMessage()}");
        }
    }

    /**
     * Delete NGINX stream configuration file.
     */
    public function deleteConfig(ServerSubdomain $subdomain): bool
    {
        if (!config('proxy.enabled', false)) {
            Log::info('Proxy functionality is disabled, skipping config deletion', [
                'subdomain_id' => $subdomain->id,
            ]);
            return false;
        }

        $configPath = config('proxy.nginx_config_path', '/etc/nginx/stream.d');
        $configFile = $configPath . '/subdomain-' . $subdomain->id . '.conf';

        try {
            if (File::exists($configFile)) {
                File::delete($configFile);
                Log::info('NGINX stream config deleted', [
                    'subdomain_id' => $subdomain->id,
                    'config_file' => $configFile,
                ]);
            }

            return true;
        } catch (\Exception $e) {
            Log::error('Failed to delete NGINX stream config', [
                'subdomain_id' => $subdomain->id,
                'config_file' => $configFile,
                'error' => $e->getMessage(),
            ]);
            throw new \Exception("Failed to delete NGINX config: {$e->getMessage()}");
        }
    }

    /**
     * Reload NGINX configuration.
     */
    public function reloadNginx(): bool
    {
        if (!config('proxy.enabled', false)) {
            Log::info('Proxy functionality is disabled, skipping NGINX reload');
            return false;
        }

        $command = config('proxy.nginx_reload_command', 'nginx -s reload');

        try {
            $output = [];
            $returnCode = 0;
            exec($command . ' 2>&1', $output, $returnCode);

            if ($returnCode === 0) {
                Log::info('NGINX reloaded successfully', [
                    'command' => $command,
                ]);
                return true;
            } else {
                $errorOutput = implode("\n", $output);
                Log::error('NGINX reload failed', [
                    'command' => $command,
                    'return_code' => $returnCode,
                    'output' => $errorOutput,
                ]);
                throw new \Exception("NGINX reload failed: {$errorOutput}");
            }
        } catch (\Exception $e) {
            Log::error('Exception during NGINX reload', [
                'command' => $command,
                'error' => $e->getMessage(),
            ]);
            throw new \Exception("Failed to reload NGINX: {$e->getMessage()}");
        }
    }

    /**
     * Validate NGINX configuration syntax.
     */
    public function validateConfig(string $config): bool
    {
        // Write config to temporary file
        $tempFile = tempnam(sys_get_temp_dir(), 'nginx_validate_');
        File::put($tempFile, $config);

        try {
            $command = "nginx -t -c {$tempFile} 2>&1";
            $output = [];
            $returnCode = 0;
            exec($command, $output, $returnCode);

            // Clean up temp file
            File::delete($tempFile);

            return $returnCode === 0;
        } catch (\Exception $e) {
            // Clean up temp file on error
            if (File::exists($tempFile)) {
                File::delete($tempFile);
            }
            return false;
        }
    }
}
